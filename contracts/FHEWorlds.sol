// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title FHEWorlds - Confidential country membership and payroll
/// @notice Allows users to confidentially select a country and claim an encrypted salary.
contract FHEWorlds is SepoliaConfig {
    struct Member {
        bool exists;
        bool salaryClaimed;
        euint32 country;
        euint32 salary;
    }

    struct CountryConfig {
        bool supported;
        euint32 salary;
    }

    mapping(address => Member) private _members;
    mapping(uint32 => CountryConfig) private _countries;
    uint32[] private _countryIds;
    address private _owner;

    event CountryJoined(address indexed account, uint32 indexed countryId);
    event SalaryClaimed(address indexed account);
    event CountrySalaryUpdated(uint32 indexed countryId);
    event CountryAdded(uint32 indexed countryId);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    error Unauthorized();
    error UnsupportedCountry();
    error AlreadyJoined();
    error SalaryAlreadyClaimed();
    error InvalidAddress();
    error AlreadySupported();
    error InvalidCountryId();
    error NotEnrolled();

    modifier onlyOwner() {
        if (msg.sender != _owner) {
            revert Unauthorized();
        }
        _;
    }

    constructor() {
        _owner = msg.sender;
        _registerCountry(1, 5200);
        _registerCountry(2, 4800);
        _registerCountry(3, 6100);
        _registerCountry(4, 4500);
    }

    /// @notice Returns the owner address.
    function owner() external view returns (address) {
        return _owner;
    }

    /// @notice Transfers ownership to a new address.
    function transferOwnership(address newOwner) external onlyOwner {
        if (newOwner == address(0)) {
            revert InvalidAddress();
        }
        address previousOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(previousOwner, newOwner);
    }

    /// @notice Returns the list of supported country identifiers.
    function getSupportedCountryIds() external view returns (uint32[] memory ids) {
        ids = new uint32[](_countryIds.length);
        for (uint256 i = 0; i < _countryIds.length; i++) {
            ids[i] = _countryIds[i];
        }
    }

    /// @notice Returns the encrypted country selection for a given account.
    function getEncryptedCountry(address account) external view returns (euint32) {
        return _members[account].country;
    }

    /// @notice Returns the encrypted salary and claim flag for a given account.
    function getEncryptedSalary(address account) external view returns (euint32 salaryCipher, bool claimed) {
        Member storage member = _members[account];
        return (member.salary, member.salaryClaimed);
    }

    /// @notice Returns whether an account has joined a country.
    function hasJoined(address account) external view returns (bool) {
        return _members[account].exists;
    }

    /// @notice Allows a user to confidentially join a country.
    /// @param countryId Plain identifier of the selected country.
    /// @param encryptedCountry The encrypted country identifier handle.
    /// @param inputProof Proof generated by the relayer.
    function joinCountry(
        uint32 countryId,
        externalEuint32 encryptedCountry,
        bytes calldata inputProof
    ) external {
        Member storage member = _members[msg.sender];
        if (member.exists) {
            revert AlreadyJoined();
        }

        CountryConfig storage config = _countries[countryId];
        if (!config.supported) {
            revert UnsupportedCountry();
        }

        euint32 countryCipher = FHE.fromExternal(encryptedCountry, inputProof);

        member.exists = true;
        member.salaryClaimed = false;
        member.country = countryCipher;
        member.salary = config.salary;

        FHE.allowThis(member.country);
        FHE.allow(member.country, msg.sender);
        FHE.allowThis(member.salary);
        FHE.allow(member.salary, msg.sender);

        emit CountryJoined(msg.sender, countryId);
    }

    /// @notice Marks the salary as claimed and returns the encrypted value.
    function claimSalary() external returns (euint32) {
        Member storage member = _members[msg.sender];
        if (!member.exists) {
            revert NotEnrolled();
        }
        if (member.salaryClaimed) {
            revert SalaryAlreadyClaimed();
        }

        member.salaryClaimed = true;
        FHE.allowThis(member.salary);
        FHE.allow(member.salary, msg.sender);

        emit SalaryClaimed(msg.sender);
        return member.salary;
    }

    /// @notice Updates an existing country's salary with an encrypted value.
    function updateCountrySalary(
        uint32 countryId,
        externalEuint32 encryptedSalary,
        bytes calldata proof
    ) external onlyOwner {
        CountryConfig storage config = _countries[countryId];
        if (!config.supported) {
            revert UnsupportedCountry();
        }

        euint32 salaryCipher = FHE.fromExternal(encryptedSalary, proof);
        config.salary = salaryCipher;
        FHE.allowThis(config.salary);

        emit CountrySalaryUpdated(countryId);
    }

    /// @notice Adds a new country with an encrypted salary.
    function addCountry(
        uint32 countryId,
        externalEuint32 encryptedSalary,
        bytes calldata proof
    ) external onlyOwner {
        if (countryId == 0) {
            revert InvalidCountryId();
        }
        CountryConfig storage config = _countries[countryId];
        if (config.supported) {
            revert AlreadySupported();
        }

        euint32 salaryCipher = FHE.fromExternal(encryptedSalary, proof);
        config.supported = true;
        config.salary = salaryCipher;
        FHE.allowThis(config.salary);

        _pushCountryId(countryId);
        emit CountryAdded(countryId);
    }

    function _registerCountry(uint32 countryId, uint32 salaryInDollars) internal {
        if (countryId == 0) {
            revert InvalidCountryId();
        }
        CountryConfig storage config = _countries[countryId];
        config.supported = true;
        config.salary = FHE.asEuint32(salaryInDollars);
        FHE.allowThis(config.salary);
        _pushCountryId(countryId);
        emit CountryAdded(countryId);
        emit CountrySalaryUpdated(countryId);
    }

    function _pushCountryId(uint32 countryId) private {
        for (uint256 i = 0; i < _countryIds.length; i++) {
            if (_countryIds[i] == countryId) {
                return;
            }
        }
        _countryIds.push(countryId);
    }
}
